# Week1学习笔记

## Lecture 3
---

### 1. 链表

* #### 节点数据类型定义:
```C
typedef struct Node {
    int data;
    struct Node* next;
} Node;
```
* #### 时间复杂度：
- 插入(头插，尾插)、删除、更新： O(1)  
> O(1)是指在已经确定了操作的目标节点的前提下，即已经完成了O(n)的查找操作
- 查找：O(n)

---

### 2. 跳表
跳表是用来加速**有序**链表的查找速度的，与平衡二叉树、二分查找的思想类似，但是出现比较晚。

通过多级索引，加快搜索速度，换个角度看其实是一种二叉树结构。

第k级索引节点个数是 n/(2^k)。
例如：索引有h级，最高级索引2个节点, 即 n/(2^h) = 2, 则 `h=log2(n)-1`。 

查询时间复杂度: O(logn)

---


### Tips
#### 1. 解决无法暴力枚举但是有一些规律的问题，要找最近重复子问题。 

比如爬楼梯问题，实际是求斐波那契数列第n个值。这是通过分析台阶数和方案数的关系得来的，分析此问题的过程就是找通项公式的过程，先简单列举出前几种情况，然后通过数学归纳法找出更一般的情况。

台阶数 = 1: 仅 1 种方案

台阶数 = 2: 有 2 种方案

**台阶数 = 3: 前两种情况的方案数之和** 

分析第三级台阶: 因为**基本操作**只有两种(走两级、走一级)， 所以第上到第三级时最后一步**要么**是走一级上来的，**要么**是走两级上来的。 

将"目前站在第三级台阶上"作为一种状态，要达到这种状态的最后一次可能的**操作**：
* 走一级的方式上来的。前一步在第二级台阶上, 达到"在第二级台阶上"这个状态有多少种方案是已经分析过的(台阶数=2的情况)，
* 走两级的方式上来的。前一步在第一级台阶上, 此情况的方案数也已计算过。

那么达到**当前状态**总的方案数就是两种操作方式所对应的前一种状态已有的方案数相加。
而前一种状态有多少个分支，就是取决于**基本操作**有多少种。

总结：求递推公式就是找到最后一种状态的前一步的所有状态。前一步有多少种方案通常就是**基本操作**的数量。

F(n) = F(n-1) + F(n-2) `#只有两种基本操作,也就是两种上一步状态` 也就是超哥说的"最近重复子问题"。

实际上目前大部分计算机程序都是由大量简单的流程控制组成的，分支、循环、递归都是在重复的做某件事；找到问题中的规律，就可以用重复运算的方式解决问题。


## Lecture 4 栈、队列

TODO: 
> 1. Video:14:19 使用新Java QueueAPI 改写视频中示例
> 2. 分析Java Queue和PrivityQueue的源码 背后如何实现的， 有何理解